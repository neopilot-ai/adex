import React, { useState } from 'react';
import './App.css';
import PromptComposer from './components/PromptComposer';
import DiffViewer from './components/DiffViewer';
import StreamingDiffViewer from './components/StreamingDiffViewer';
import ErrorBoundary from './components/ErrorBoundary';

function App() {
  const [patches, setPatches] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [isStreaming, setIsStreaming] = useState(false);
  const [streamingComplete, setStreamingComplete] = useState(false);
  const [error, setError] = useState(null);
  const [retryCount, setRetryCount] = useState(0);

  const handlePromptSubmit = async (prompt, attachments) => {
    setIsLoading(true);
    setIsStreaming(true);
    setStreamingComplete(false);
    setPatches([]);

    try {
      // Prepare the request payload for streaming
      const requestData = {
        prompt: prompt,
        context: attachments.length > 0 ? {
          attachments: attachments.map(att => ({
            name: att.name,
            type: att.type,
            content: att.type === 'url' ? att.content : 'file_content_placeholder'
          }))
        } : undefined,
        agent_sequence: ["spec", "code", "reviewer"],
        options: {
          streaming: true
        }
      };

      // For now, simulate streaming with regular API call
      // In a full implementation, this would connect to the streaming endpoint
      const response = await fetch('http://localhost:3000/api/v1/orchestrate', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(requestData)
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const result = await response.json();

      // Convert the backend response to the expected patch format
      if (result.result && result.result.patch) {
        const patches = parsePatchResponse(result.result.patch);
        setPatches(patches);
      } else {
        const mockPatches = [
          {
            filePath: 'src/components/Example.js',
            oldContent: 'console.log("old code");',
            newContent: JSON.stringify(result.result, null, 2),
            explanation: 'Generated response from orchestrator'
          }
        ];
        setPatches(mockPatches);
      }

      setStreamingComplete(true);

    } catch (error) {
      console.error('Error submitting prompt:', error);
      setError(error);
      setRetryCount(prev => prev + 1);
    } finally {
      setIsLoading(false);
      setIsStreaming(false);
    }
  };

  const handleRetry = () => {
    setError(null);
    setRetryCount(0);
  };

  const clearResults = () => {
    setPatches([]);
    setError(null);
    setStreamingComplete(false);
  };

  const handleStreamingComplete = (result) => {
    setIsStreaming(false);
    setStreamingComplete(true);
    // Process the streaming result
    if (result && result.patch) {
      const patches = parsePatchResponse(result.patch);
      setPatches(patches);
    }
  };

  const handleStreamingError = (error) => {
    setIsStreaming(false);
    setIsLoading(false);
    console.error('Streaming error:', error);
    alert('Streaming error occurred. Please try again.');
  };

  // Helper function to parse patch response
  const parsePatchResponse = (patchContent) => {
    // This is a simplified patch parser - in a real implementation,
    // you'd want more sophisticated parsing
    try {
      const lines = patchContent.split('\n');
      const patches = [];
      let currentFile = null;
      let oldContent = '';
      let newContent = '';

      for (const line of lines) {
        if (line.startsWith('+++') || line.startsWith('---')) {
          // Skip diff headers
          continue;
        } else if (line.startsWith('@@')) {
          // New hunk
          if (currentFile && oldContent && newContent) {
            patches.push({
              filePath: currentFile,
              oldContent: oldContent.trim(),
              newContent: newContent.trim(),
              explanation: 'Code changes generated by orchestrator'
            });
          }
          // Extract filename from hunk header if possible
          const match = line.match(/@@.*?\+.*? (.*?)\s*@@/);
          if (match) {
            currentFile = match[1];
          }
          oldContent = '';
          newContent = '';
        } else if (line.startsWith('+') && !line.startsWith('+++')) {
          newContent += line.substring(1) + '\n';
        } else if (line.startsWith('-') && !line.startsWith('---')) {
          oldContent += line.substring(1) + '\n';
        } else if (line.startsWith(' ')) {
          oldContent += line.substring(1) + '\n';
          newContent += line.substring(1) + '\n';
        }
      }

      // Add the final patch if exists
      if (currentFile && (oldContent || newContent)) {
        patches.push({
          filePath: currentFile,
          oldContent: oldContent.trim(),
          newContent: newContent.trim(),
          explanation: 'Code changes generated by orchestrator'
        });
      }

      return patches.length > 0 ? patches : [{
        filePath: 'response.txt',
        oldContent: 'No file changes detected',
        newContent: patchContent,
        explanation: 'Orchestrator response'
      }];
    } catch (error) {
      // If parsing fails, return the raw response
      return [{
        filePath: 'response.txt',
        oldContent: 'Error parsing response',
        newContent: patchContent || 'No content received',
        explanation: 'Raw orchestrator response'
      }];
    }
  };

  return (
    <div className="App">
      <header className="App-header">
        <h1>Codex - Agentic Development Environment</h1>
      </header>
      <main className="App-main">
        <div className="prompt-section">
          <PromptComposer onSubmit={handlePromptSubmit} isLoading={isLoading} />
        </div>

        {error && (
          <div className="error-section">
            <div className="error-banner">
              <div className="error-header">
                <span className="error-icon">❌</span>
                <h3>Request Failed</h3>
              </div>
              <p className="error-message">{error.message}</p>
              <div className="error-actions">
                <button onClick={handleRetry} className="retry-button">
                  🔄 Retry Request
                </button>
                <button onClick={clearResults} className="clear-button">
                  🗑️ Clear Results
                </button>
              </div>
              {retryCount > 1 && (
                <p className="retry-warning">
                  ⚠️ Multiple failures detected. Please check your connection and backend server status.
                </p>
              )}
            </div>
          </div>
        )}

        {isStreaming && (
          <div className="streaming-section">
            <StreamingDiffViewer
              isStreaming={isStreaming}
              onStreamingComplete={handleStreamingComplete}
              onStreamingError={handleStreamingError}
            />
          </div>
        )}

        {patches.length > 0 && !isStreaming && !error && (
          <div className="diff-section">
            <div className="results-header">
              <h2>Generated Patches</h2>
              <button onClick={clearResults} className="clear-results-button">
                🗑️ Clear
              </button>
            </div>
            <DiffViewer patches={patches} />
          </div>
        )}
      </main>
    </div>
  );
}

export default App;
